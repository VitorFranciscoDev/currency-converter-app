import 'package:currency_converter/domain/entities/user.dart';

/// Repository contract for authentication and user management operations.
///
/// This abstract class defines the contract (interface) for authentication
/// operations in the domain layer, following the Repository Pattern and
/// Clean Architecture principles. It acts as a boundary between the domain
/// layer and the data layer, allowing for flexibility in data source
/// implementation (local database, remote API, mock data, etc.).
///
/// ## Responsibilities:
/// - Define authentication operations (login, registration)
/// - Define user CRUD operations (Create, Read, Update, Delete)
/// - Maintain independence from implementation details
/// - Provide a consistent API for use cases
///
/// ## Implementation:
/// This interface should be implemented in the data layer (e.g.,
/// `AuthRepositoryImpl`) which handles the actual data operations and
/// exception handling, converting data source exceptions into domain failures.
///
/// ## Usage Example:
/// ```dart
/// class LoginUseCase {
///   final AuthRepository repository;
///
///   Future<Either<Failure, User>> call(String email, String password) {
///     return repository.login(email, password);
///   }
/// }
/// ```
///
/// ## Design Patterns Applied:
/// - **Repository Pattern**: Abstracts data access logic
/// - **Dependency Inversion Principle**: High-level modules depend on abstractions
/// - **Interface Segregation**: Focused contract for auth operations
abstract class AuthRepository {
  /// Authenticates a user with email and password credentials.
  ///
  /// Attempts to authenticate a user by validating the provided credentials
  /// against stored user data. This method should verify the password hash
  /// and return the user information if authentication is successful.
  ///
  /// Parameters:
  /// - [email]: The user's email address (must be valid and registered).
  /// - [password]: The user's password (will be compared against stored hash).
  ///
  /// Returns:
  /// - [User] object if authentication is successful.
  /// - `null` if authentication fails (invalid credentials or user not found).
  ///
  /// Throws:
  /// - [DatabaseException]: If there's an error accessing the database.
  /// - [NetworkException]: If there's a network connectivity issue (for remote auth).
  /// - [InvalidCredentialsException]: If email or password is incorrect.
  ///
  /// Example:
  /// ```dart
  /// final user = await repository.login('john@example.com', 'password123');
  /// if (user != null) {
  ///   print('Login successful: ${user.name}');
  /// } else {
  ///   print('Login failed');
  /// }
  /// ```
  ///
  /// **Security Note**: The password parameter should be hashed before
  /// comparison. Never store or log plain-text passwords.
  Future<User?> login(String email, String password);

  /// Retrieves a user by their email address.
  ///
  /// Searches for a user in the data source using their email as the
  /// unique identifier. This method is commonly used for:
  /// - Validating email uniqueness during registration
  /// - Password recovery flows
  /// - Checking if a user exists before certain operations
  ///
  /// Parameters:
  /// - [email]: The email address to search for.
  ///
  /// Returns:
  /// - [User] object if a user with the specified email exists.
  /// - `null` if no user is found with that email.
  ///
  /// Throws:
  /// - [DatabaseException]: If there's an error querying the database.
  /// - [NetworkException]: If there's a network issue (for remote data source).
  /// - [ValidationException]: If the email format is invalid.
  ///
  /// Example:
  /// ```dart
  /// // Check if email is already registered
  /// final existingUser = await repository.getUserByEmail('john@example.com');
  /// if (existingUser != null) {
  ///   print('Email is already registered');
  /// } else {
  ///   print('Email is available');
  /// }
  /// ```
  Future<User?> getUserByEmail(String email);

  /// Adds a new user to the data source.
  ///
  /// Creates a new user record in the data source with the provided
  /// user information. The user's ID should be null or 0 when calling
  /// this method, as the ID will be auto-generated by the data source.
  ///
  /// Parameters:
  /// - [user]: The user object to be added. The [user.id] should be null
  ///   or 0 as it will be generated by the database.
  ///
  /// Returns:
  /// - The generated user ID (positive integer) if the operation is successful.
  /// - `0` if the operation fails.
  ///
  /// Throws:
  /// - [DatabaseException]: If there's an error inserting into the database.
  /// - [DuplicateEmailException]: If a user with the same email already exists.
  /// - [ValidationException]: If user data validation fails.
  /// - [NetworkException]: If there's a network issue (for remote data source).
  ///
  /// Example:
  /// ```dart
  /// final newUser = User(
  ///   name: 'John Doe',
  ///   email: 'john@example.com',
  ///   password: 'hashedPassword',
  /// );
  ///
  /// final userId = await repository.addUser(newUser);
  /// if (userId > 0) {
  ///   print('User created with ID: $userId');
  /// } else {
  ///   print('Failed to create user');
  /// }
  /// ```
  ///
  /// **Security Note**: Ensure the password is hashed before calling this method.
  /// Never store plain-text passwords in the database.
  Future<int> addUser(User user);

  /// Deletes a user from the data source.
  ///
  /// Permanently removes a user record from the data source based on
  /// their unique identifier. This is a destructive operation and should
  /// be used with caution, potentially with additional confirmation steps
  /// in the UI layer.
  ///
  /// Parameters:
  /// - [id]: The unique identifier of the user to delete.
  ///   Can be `null` to handle cases where ID might not be available.
  ///
  /// Returns:
  /// - The number of affected rows (typically `1` if successful).
  /// - `0` if the operation fails or the user doesn't exist.
  ///
  /// Throws:
  /// - [DatabaseException]: If there's an error deleting from the database.
  /// - [UserNotFoundException]: If the user with specified ID doesn't exist.
  /// - [ValidationException]: If the ID is null or invalid.
  /// - [NetworkException]: If there's a network issue (for remote data source).
  ///
  /// Example:
  /// ```dart
  /// final rowsAffected = await repository.deleteUser(userId);
  /// if (rowsAffected > 0) {
  ///   print('User deleted successfully');
  /// } else {
  ///   print('Failed to delete user or user not found');
  /// }
  /// ```
  ///
  /// **Important**: Consider implementing soft delete (marking as deleted)
  /// instead of hard delete for better data integrity and recovery options.
  Future<int> deleteUser(int? id);

  /// Updates an existing user's information in the data source.
  ///
  /// Modifies an existing user record with new information. The user's ID
  /// must be present and valid to identify which record to update.
  /// All other fields will be updated with the values from the provided
  /// user object.
  ///
  /// Parameters:
  /// - [user]: The user object with updated information.
  ///   The [user.id] must be a valid existing user ID.
  ///
  /// Returns:
  /// - The number of affected rows (typically `1` if successful).
  /// - `0` if the operation fails or the user doesn't exist.
  ///
  /// Throws:
  /// - [DatabaseException]: If there's an error updating the database.
  /// - [UserNotFoundException]: If the user with specified ID doesn't exist.
  /// - [ValidationException]: If the user data validation fails.
  /// - [DuplicateEmailException]: If updating email and it already exists.
  /// - [NetworkException]: If there's a network issue (for remote data source).
  ///
  /// Example:
  /// ```dart
  /// final updatedUser = existingUser.copyWith(
  ///   name: 'Jane Doe',
  ///   email: 'jane@example.com',
  /// );
  ///
  /// final rowsAffected = await repository.updateUser(updatedUser);
  /// if (rowsAffected > 0) {
  ///   print('User updated successfully');
  /// } else {
  ///   print('Failed to update user');
  /// }
  /// ```
  ///
  /// **Security Note**: If updating the password, ensure it's hashed
  /// before calling this method. Validate that the user has permission
  /// to update this specific user record.
  Future<int> updateUser(User user);
}